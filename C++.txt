Const

const int a = 10; // constant `a` can not be changed

const int *p = &a; // pointer `p` points at constant `a`, `p` can be changed, the value `*p` can not

int * const p = new int(5); // constant pointer `p` points at an integer 5, `p` can not be changed, but the value `*p` can

const int * const p = &a; // constant pointer points at the integer constant, nothing can be changed without casts.

Rule:
if `const` is on the left of `*` - it's a pointer on a constant
if `const` is on the right of `*` - it's a constant pointer

Function generated by compiler:
- Default constructor
- Copy constructor
- Operator=
- Destructor

Forbid automaticaly generated functions:
- Declare them in private section
- Use `delete` in declaration SomeClass(const SomeClass &obj) = delete; //C++11

If destructor is in private section then instances of this class can be allocated in the heap only! (otherwise it won't be compiled)



Calling Virtual functions in Constructor / Destructor
It's bettere to avoid calling virtual functions in const/dest

Virtual constructor
Example:
class Dog {	
public:
    dog() { bark(); }
	virtual void bark() { cout << "Dog is born!\n"; }
	virtual ~Dog() { cout << "Deleting a Dog object<<endl; }
};

class yellowdog :public Dog {
public:
	yellowdog() { bark(); }
	void bark() { cout << "Yellow dog is born!\n"; }
	~yellowdog() { cout << "Deleting a YellowDog object" << endl; }
};

void func(Dog *dog) {
	Dog *new_dog = new Dog(*dog);
	new_dog->bark();
	delete new_dog;
}

int main() {
    Dog dog;
	yellowdog ydog;

	func(&dog);
	func(&ydog);
}

Parameter `dog` in `func` will be a pointer at `yellowdog` object but after `Dog *new_dog = new Dog(*dog);` will be created a `Dog` object

class Dog {	
public:
    dog() { bark(); }
	virtual void bark() { cout << "Dog is born!\n"; }
	virtual Dog* clone() { return new Dog(*this); }
	virtual ~Dog() { cout << "Deleting a Dog object<<endl; }
};

class yellowdog :public Dog {
public:
	yellowdog() { bark(); }
	void bark() { cout << "Yellow dog is born!\n"; }
	virtual yellowdog* clone() { return new yellowdog(*this); }
	~yellowdog() { cout << "Deleting a YellowDog object" << endl; }
};

void func(Dog *dog) {
	Dog *new_dog = dog->clone();
	new_dog->bark();
	delete new_dog;
}

Now the `bark()` method will depend on the object type which was passed to `func()`.

Static polymorphism
Declare Base class as a template class. Before calling a virtual function (where we expect dynamic polymorphism) static_cast `this` to the type which is used during template instanceation.

struct TreeNode {TreeNode *left, *right;};

class Generic_Parser {
   public:
   void parse_preorder(TreeNode* node) {
      if (node) {
         process_node(node);
         parse_preorder(node->left);
         parse_preorder(node->right);
      }
   }
   private:
   virtual void process_node(TreeNode* node) { }
};

class EmployeeChart_Parser : public Generic_Parser {
   private:
   void process_node(TreeNode* node) {
       cout << "Customized process_node() for EmployeeChart.\n";
   }
};
   
int main() {
   ...
   EmployeeChart_Parser ep;
   ep.parse_preorder(root);
   ...
}


// TMP: Template Metaprogramming
template <typename T> class Generic_Parser {
   public:
   void parse_preorder(TreeNode* node) {
       if (node) {
           process_node(node);
           parse_preorder(node->left);
           parse_preorder(node->right);
       }
   }
   void process_node(TreeNode* node) {
       static_cast<T*>(this)->process_node(node);
   }
};

class EmployeeChart_Parser : public Generic_Parser<EmployeeChart_Parser> {
   public:
   void process_node(TreeNode* node) {
       cout << "Customized process_node() for EmployeeChart.\n";
   }
};
   
int main() {
   ...
   EmployeeChart_Parser ep;
   ep.parse_preorder(root);
   ...
}